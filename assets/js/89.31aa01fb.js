(window.webpackJsonp=window.webpackJsonp||[]).push([[89],{647:function(t,a,s){"use strict";s.r(a);var e=s(35),i=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"sugar-surface-aligned-gaussian-splatting-for-efficient-3d-mesh-reconstruction-and-high-quality-mesh-rendering"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#sugar-surface-aligned-gaussian-splatting-for-efficient-3d-mesh-reconstruction-and-high-quality-mesh-rendering"}},[t._v("#")]),t._v(" SuGaR: Surface-Aligned Gaussian Splatting for Efficient 3D Mesh Reconstruction and High-Quality Mesh Rendering")]),t._v(" "),s("link",{attrs:{rel:"stylesheet",href:"/notes/katex.min.css"}}),t._v(" "),s("p",[t._v("precise and extremely fast mesh extraction from 3D Gaussian Splatting")]),t._v(" "),s("h3",{attrs:{id:"contributions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#contributions"}},[t._v("#")]),t._v(" Contributions")]),t._v(" "),s("ul",[s("li",[t._v("a "),s("strong",[t._v("regularization term")]),t._v(" that encourages the gaussians to align well with the surface of the scene")]),t._v(" "),s("li",[t._v("a method that exploits this alignment to "),s("strong",[t._v("extract a mesh")]),t._v(" from the Gaussians using Poisson reconstruction, which is fast, scalable, and preserves details, in contrast to the Marching Cubes algorithm usually applied to extract meshes from Neural SDFs")]),t._v(" "),s("li",[t._v("an optional refinement strategy that binds gaussians to the surface of the mesh, and "),s("strong",[t._v("jointly optimizes")]),t._v(" these Gaussians and the mesh through Gaussian splatting rendering")])]),t._v(" "),s("h3",{attrs:{id:"intro"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#intro"}},[t._v("#")]),t._v(" Intro")]),t._v(" "),s("p",[t._v("the gaussians are unstructured")]),t._v(" "),s("p",[t._v("Gaussian Splatting performs densification in order to capture details of the scene with highfidelity... This results in a density function that is close to zero almost everywhere(?), and the Marching Cubes algorithm(?) fails to extract proper level sets(?) of such a sparse density function even with a fine voxel grid")]),t._v(" "),s("p",[t._v("Instead, Poisson reconstruction algorithm, scalable")]),t._v(" "),s("h3",{attrs:{id:"related-works"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#related-works"}},[t._v("#")]),t._v(" Related works")]),t._v(" "),s("p",[t._v("light fields(?) Their work emphasized the importance of efficiently traversing volumetric data to produce realistic images(?)"),s("br"),t._v("\nTraditional mesh-based IBR methods"),s("br"),t._v("\nVolumetric IBR methods - NeRF"),s("br"),t._v("\nHybrid IBR methods"),s("br"),t._v("\nPoint-based IBR methods")]),t._v(" "),s("h3",{attrs:{id:"methods"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#methods"}},[t._v("#")]),t._v(" Methods")]),t._v(" "),s("ol",[s("li",[s("p",[s("strong",[t._v("regularization term")])]),t._v(" "),s("p",[t._v("the ideal SDF "),s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[s("semantics",[s("mrow",[s("mi",[t._v("f")])],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("f")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"0.8889em","vertical-align":"-0.1944em"}}),s("span",{staticClass:"mord mathnormal",staticStyle:{"margin-right":"0.10764em"}},[t._v("f")])])])]),t._v(" is expected to be")]),t._v(" "),s("ul",[s("li",[t._v("well spread (the density of any position can be well approximated by only considering the closest gaussian)")]),t._v(" "),s("li",[t._v("flat (one of scaling factors close to 0)")]),t._v(" "),s("li",[t._v("opaque (alpha = 1)")])]),t._v(" "),s("p",[t._v("computing a slightly different loss relying on an SDF rather than on density further increases the alignment of gaussians with the surface of the scene"),s("br"),t._v("\nthe zero-crossings(?) of the Signed Distance Function")]),t._v(" "),s("p",[t._v("We also add a regularization term to encourage the normals of SDF "),s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[s("semantics",[s("mrow",[s("mi",[t._v("f")])],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("f")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"0.8889em","vertical-align":"-0.1944em"}}),s("span",{staticClass:"mord mathnormal",staticStyle:{"margin-right":"0.10764em"}},[t._v("f")])])])]),t._v(" (ideal) and the normals of SDF "),s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[s("semantics",[s("mrow",[s("mover",{attrs:{accent:"true"}},[s("mi",[t._v("f")]),s("mo",[t._v("ˉ")])],1)],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("\\bar{f}")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"1.0257em","vertical-align":"-0.1944em"}}),s("span",{staticClass:"mord accent"},[s("span",{staticClass:"vlist-t vlist-t2"},[s("span",{staticClass:"vlist-r"},[s("span",{staticClass:"vlist",staticStyle:{height:"0.8312em"}},[s("span",{staticStyle:{top:"-3em"}},[s("span",{staticClass:"pstrut",staticStyle:{height:"3em"}}),s("span",{staticClass:"mord mathnormal",staticStyle:{"margin-right":"0.10764em"}},[t._v("f")])]),s("span",{staticStyle:{top:"-3.2634em"}},[s("span",{staticClass:"pstrut",staticStyle:{height:"3em"}}),s("span",{staticClass:"accent-body",staticStyle:{left:"-0.0833em"}},[s("span",{staticClass:"mord"},[t._v("ˉ")])])])]),s("span",{staticClass:"vlist-s"},[t._v("​")])]),s("span",{staticClass:"vlist-r"},[s("span",{staticClass:"vlist",staticStyle:{height:"0.1944em"}},[s("span")])])])])])])]),t._v(" (estimated under current gaussians) to also be similar")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("mesh extraction")])])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("refinement")])]),t._v(" "),s("p",[t._v("instantiate a set of new thin 3D gaussians from each mesh triangle. The gaussians have only 2 learnable scaling factors and only 1 learnable 2D rotation")])])]),t._v(" "),s("h3",{attrs:{id:"results"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#results"}},[t._v("#")]),t._v(" Results")]),t._v(" "),s("p",[t._v("slightly(?) worse than vanilla 3DGS and Mip-NeRF360")])])}),[],!1,null,null,null);a.default=i.exports}}]);